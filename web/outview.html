<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

</style>
<body>


 <link rel="stylesheet" href="https://code.jquery.com/ui/1.9.2/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-1.9.1.js"></script>
  <script src="https://code.jquery.com/ui/1.9.2/jquery-ui.js"></script> 
<script src="http://d3js.org/d3.v3.min.js"></script>




<script>
var width = 1400,
    height = 900;
var maxColor = 0;
var localMax = 0;	
	
var color;

var force = d3.layout.force()
    .charge(-80)
    .linkDistance(20)
    .size([width, height]);

var svg = d3.select("body")
    .append("div")
    .attr("id", "svg-container")
    .append("svg")
    .attr("id", "svg")
    .attr("width", width)
    .attr("height", height);

var zoomListener = d3.behavior.zoom()
  .scaleExtent([0.1, 14])
  .on("zoom", zoomed);
	
zoomListener(svg);
	
var colored = [];	

function getLocalMax(links) {
	maxval = 0;
	
	links.forEach(function(d) {
		if(d.weight > maxval) 
			maxval = d.weight;
		});
		
		
	var numMax = 0;
	links.forEach(function(d) {
		if(d.weight === maxval) {
			numMax++;
			console.log("Logging Max Val");
			//console.log(d);
		}
	});
	console.log(numMax);	
		
	return maxval;
}



function getMaxID(links) {
	return 259;
}

function setColorRange(maxval) {
	catagories = [];

	for(i = maxval; i > 0; i--) {
		catagories.push(i.toString());
	}
	console.log(maxval);
	console.log(catagories);

	color = d3.scale.ordinal()
		.domain(catagories)
		.range(d3.range(catagories.length).map(d3.scale.linear()
			.domain([0, catagories.length - 1])
			.range(["#ff0000", "grey"])
			.interpolate(d3.interpolateHcl)));
}


d3.json("027656A.json", function(error, graph) {
  force
      .nodes(graph.nodes)
      .links(graph.links);
      
		var n = 100;
		force.start();
		for (var i = n * n; i > 0; --i) force.tick();
		force.stop();
	 
	  console.log("Number of verices " + graph.nodes.length);
	  console.log("Number of Edges " + graph.links.length);

  var maxval = getMaxID(graph.links);
  localMax = getLocalMax(graph.links);
  setColorRange(localMax);
  
  
  var link = svg.selectAll(".link")
      .data(graph.links.filter(function(d) {
		if(d.weight > 0) return true;
		return false;
	  }))
    .enter().append("line")
	 .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .attr("class", "link")
	  .style("stroke", function(d) { return color(d.weight.toString()); })
	  .style("stroke-width", function(d) { return d.weight / (16 * maxval)/*( 16 * localMax )*/ });
	  
 var inciCount = 0;
 var oCount = 0;
 var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("path")
      .attr("class", "node")
	  .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
      .attr("d", d3.svg.symbol()
			.type(function(d) { 
			if(isInci(d)) {
				return d3.svg.symbolTypes[0];
			} else {
				return d3.svg.symbolTypes[1];
			} })
			.size(function(d) { 
				if(!isInci(d)) {
					return 1;
				}
					var sw = 0;
					graph.links.forEach(function(m) {
						if(m.source.id === d.id || m.target.id === d.id) {
							sw = m.weight / maxval;
							return;
						}
					
					});
				return sw;
				}))
      .style("fill", function(d) { return "#000000"; })
	  .style("stroke", function(d) {return "#ffffff"; })
	  .style("stroke-width", function(d) { return "0.25px" })  
	  .on("mouseover", function(d) { 
	  /* Mouse over listener for node selection. */
	  d3.select(this).style("fill", "red");
	  console.log(d);  
	  svg.selectAll(".link")
		.style("stroke-width", function(l) {
            if(l.source.id === d.id || l.target.id == d.id) {
		    return 0.5;
				}
			return 0;
         });
	  
	  
	  
	  
	  });
      

	  
	  console.log("Number of Incident Attrs " +  inciCount);
	  console.log(oCount);
 /* node.append("title")
      .text(function(d) { return d.value + ':' + d.attrn; });
	 */
  console.log("binding click listener");

	  
  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("transform", function(d) {
		return "translate(" + d.x + "," + d.y + ")";
		});
  });

  setSlider(graph);
  //takeScreenShot();
});


function zoomed() {
	console.log("Calling zoom");
	svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}	

var currMin = 0;
var currMax = 0;
//Sets the slider used to control the types of edges seen
function setSlider(graph) {


d3.select("body").append("div")
   .attr("id", "amount");

d3.select("body").append("div")
   .attr("id", "slider");

//Get the largest edge for our range
var maxval = getMaxID(graph.links);

$("#amount").html('Range from 0 to ' + maxval);

currMax = maxval * 100;

$("#slider").slider({
   range: true, 
   animate: false,
   min: 0,
   max: maxval,
   values: [ 0, maxval],
   slide: function(event, ui) {
	$("#amount").html('Range from ' + ui.values[0] + ' to ' + ui.values[1]);  

	console.log("Comparing " + currMin + ":" + ui.values[0]);
	if(currMin === ui.values[0] && currMax === ui.values[1]) {
		console.log("Returning and saving space");
		return;
	}

	currMin = ui.values[0];
	currMax = ui.values[1];

	setTimeout(function() {
	svg.selectAll(".link")
	.style("stroke-width", function(d) {
            if(d.weight >= ui.values[0] && d.weight <= ui.values[1]) {
				return d.weight / (16 * maxval)/*( 16 * localMax )*/
				}
			return 0;
         });
	}, 0);



   }
});

}


function takeScreenShot() {

console.log("Logging SVG");
console.log(svg.html());

//Open a websocket
if("WebSocket" in window) {
   console.log("Web Sockets are supported!");
   var ws = new WebSocket("ws://localhost:9998");

   ws.onoopen = function() {
    ws.send('file.png||' + svg.html());
    console.log("Sending SVG/HTML");
    }
   ws.onmessage = function(evt) {
    console.log(evt.data);
    }
   ws.onclose = function() {
    console.log("Socket closed");
    }

} else {
   console.log("Web Sockets not supported!");
}

}







function isInci(d) { 
            var res = d.id.split(":");
            if(res[res.length - 1] == "inci") {
                return true;		
           } else {
                return false;
             }
	}
	
function getCol(weight) {
	return color[weight - 1];
};

</script>
